# Java 学习笔记
## Chapter1:类和对象
类是一种描述不存在实体，对象是一个符合类描述的实体
类是一个.java的文件，以文本的形式存储在本地；对象是存储在内存当中的实体；

一、构造方法
定义：
	实例化对象的时候，对属性的一些操作！（对象初始化）
特点：
	1. 当没有设计构造方法的时候，会有一个隐藏式的默认构造方法；
	2. 当设计了构造方法的时候，那个隐藏式的默认构造方法就不存在了；

二、static关键字
修饰属性：
	类属性，加载类的时候进入内存，可以使用类访问，也可以使用实例访问；
修饰方法：
	类方法，加载类的时候写入内存，方法中可以直接使用static变量，不能直接使用成员变量，如果要使用成员变量必须通过实例化的对象调用；

重点：##静态属性和方法入内存的时间是加载类的时候，早已对象的实例化##

三、代码块
普通代码块 、 static代码块
对比：
	执行时机：创建对象的时候调用  VS  加载类的时候调用
	功能：初始化属性 VS 初始化属性
	作用变量：普通成员变量和静态变量  VS  静态变量

拓展：**代码块的执行早于构造方法**

## Chapter 2:封装
2.1、
核心：对属性的访问操作进行限制🚫，保护属性的安全性；

2.2、Java包 package， 解决类名的重复问题；

2.3 Java中的访问修饰符
	private:当前类中访问
	默认:当前类 + 当前包内访问
	protect:当前类 + 当前包内的类 + 子类 访问
	public:都能访问
	
2.4 this关键字

## Chapter 3:继承
3.1 继承的好处
	1. 子类拥有父类所有的属性和方法；
	2. 实现代码复用；
	
	*. 父类的属性如果用“private”修饰则不可以被子类继承到；

3.2 方法的重写
	方法名 、返回值类型、 参数列表 完全一致的才能构成重写；

3.3 继承的初始化顺序；
	1. 构造方法顺序：从父类由上到下的执行顺序，最后执行的构造方法覆盖之前的构造方法！
	2. 属性初始化的顺序：声明属性时初始化--》普通代码块初始化--》构造方法
	一个实例：
		//默认Animal和Dog都有属性初始化，普通代码块，构造方法
		Animal
		Dog
		Dog extends Animal
		Dog dog = new Dog();
		/*
		该new方法调用的时候，首先调用Animal的初始化，执行属性声明赋值 --》 普通代码块 --》 Animal初始化方法
		再调用Dog类的初始化，执行属性声明赋值 --》 普通代码块 --》 Animal初始化方法
		*/	
	
3.4 fianl 关键字
	1. 修饰类 --》 不能被继承；
	2. 修饰方法 --》 方法不能被重写；
	3. 修饰属性 --》 属性值就不会隐式的初始化(隐式指赋予默认值如[0, 0.0, false...])，必须显示的完成初始化
	可以在声明赋值初始化，代码块，构造方法，但是只能在一处进行初始化；
	4. 修饰变量 --》变量的值只能赋值一次，即变为常量；

3.5 super 关键字
	对象的内部使用，可以代表父类对象
	1. 访问父类的属性
		super.age
	2. 访问父类方法
		super.eat(){}
	** 子类对象创建的时候，会层层调用父类的构造方法，获取到整个类结构中信息，然后再调用这个子类本身的构造方法 **

3.6 Object类
	最根本的类
	1. toString()方法
		返回对象的hashCode码(对象地址字符串)
	2. equals()方法
		比较的是对象的引用是否指向同一块内存地址
	
	类对象obj.getClass()	//存储类相关信息，关注整个类的结构数据 
	VS 
	类的对象new ClassName()//存储类的属性相关信息，关注当前实例的数据属性
	
## Chapter 4. 多态
4.1 Java中的多态
	1. 引用多态
		父类的引用(以父类声明的变量)可以指向子类的对象 	//Animal dog = new Dog();
		父类的引用(以父类声明的变量)可以指向本类的对象   //Animal dog = new Animal();
	2. 方法多态
		创建本类对象时，调用的方法为本类方法；
		创建子类对象时，调用的方法为子类重写的方法或者继承的方法；
		
		*** 发散想一想🤔️，创建对象的时候开辟了内存空间，空间开始获取数据，首先获取整个类相关的信息，然后是当前实例的信息；
		这里就有这个情况，该实例化过程会获取到当前对象所处类节点到根类的信息，so 这个实例化过程获取到了当前类以及所有父类
		的相关信息，这就是父类引用可以指向子类对象，但是子类的引用绝不能指向父类的对象。
		---
		*** 再想想，这种继承的结构获取数据的时候是由下而上层层获取！所欲子类只能获取到本身的数据和其全部父类的数据，而当
		连个类处于同一个层级的时候，他们之间的数据并不通，如下边的猫和狗类，他们都只能获取到自己类里的属性方法和父类的属性
		方法！
			  Object
			  Animal
		哺乳动物	$$	孵化动物	
		
		猫 | 狗	$$
		---
		*** 父类的引用不能调用子类独有的方法，比如
		Animal a = new Dog();
		a.watchDoor;//会报错，无法访问到这个方法！
		暂且可以这么想，寻找方法的时候是从父类的方法里边开始找，一直找到最末端的子类然后执行， 如果父类中没有找到对应的
		方法就无法继续往下找了，就报错了(粗且的帮助记忆吧)
		---

4.2 多态中的引用类型转换
1. 向上类型转换(隐式／自动类型转换)
	转换没有风险
2. 向下类型转换(强制类型转换)
	转换有风险，存在溢出风险
3. instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题
   dog instanceof Dog
   dog instanceof Animal

4. 实例
	Dog dd = new Dog();
	Animal aa = dd; //将 dd 的类型由 Dog -》 Animal ， 向上的类型转换
	//Dog cc = aa;编译的时候报错，因为要将 Animal 类转换到 Dog类，向下的类型转换
	Dog cc = (Dog)aa;//这样就可以强制将 Animal类型的aa转换为Dog类型的cc；

4.3 Java中的抽象类
	
